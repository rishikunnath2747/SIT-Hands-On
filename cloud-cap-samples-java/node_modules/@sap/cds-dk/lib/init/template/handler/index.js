const cds = require('../../../cds')
const { fs: { promises: { rename } }, path: { basename, dirname, join }, exists } = cds.utils
const { readProject } = require('../../projectReader')
const { renderAndCopy } = require('../../template')
const mvn = require('../../mvn')
const { dim } = require('../../../util/term')
const { filterStringAsRegex } = require('../../add')

module.exports = class Handler extends require('../../plugin') {

  static help() {
    return 'handler stubs for service entities, actions and functions'
  }

  options() {
    return {
      'filter': {
        type: 'string',
        short: 'f',
        help: `Filter for entities, actions or functions matching the given pattern.
        For Node.js, if it contains meta characters like '^' or '*', it is treated as a regular expression,
        otherwise as an include pattern, i.e /.*bookshop.*/i
        For Java, only '*' and '**' as suffix wildcards are allowed, as in 'my.bookshop.*' or 'my.**'`
      },
      'out': {
        type: 'string',
        short: 'o',
        help: `Custom output directory.
        For Java, the default is 'handlers'. For Node.js, the default is 'srv'.`
      }
    }
  }

  canRun() {
    return true
  }

  async run() {
    const { isJava } = readProject()
    if (isJava) {
      await mvn.generate('handler')
    } else {
      await createNodeHandler()
    }
  }
}

async function createNodeHandler() {
  const { filter, force, out=cds.env.folders.srv } = cds.cli.options
  const proj = readProject()
  const csn = await loadModel()
  if (!csn)  return console.log(dim(`> Skipping, no model found`))

  const nameFilter = filterStringAsRegex(filter)

  for (const service of csn.services) {
    if (!service.$location.file)  continue

    const destFileType = proj.isTypescript ? '.ts' : '.js'
    const outPath = join(out, basename(service.$location.file.replace('.cds', destFileType)))
    const destFile = join(cds.root, outPath)
    if (!force && exists(destFile)) {
      console.log(dim(`> Skipping ${outPath}`))
      continue
    }

    proj.serviceName = service.name
    proj.serviceClass = service.name.split('.').pop()
    proj.servicePath = proj.serviceName ? (proj.serviceName.replace(/\./g, '/')) : ''

    proj.entities = Object.entries(service.entities)
      .filter(([name]) =>  name.match(nameFilter))
      .filter(([name]) => !name.match(/[._]texts$/))
      .filter(([, e])  => !e['@cds.autoexposed']) // only consider non-autoexposed entities to reduce clutter
      .map(([name]) => ({
        name,
        dataVar: name.charAt(0).toLowerCase() + name.slice(1) // lower case first letter
      }))
    if (proj.entities.length)
      proj.entityNames = proj.entities.map(e => e.name).join(', ')

    proj.operations = Object.keys(service.actions)
      .filter(name => name.match(nameFilter))
      .map(name => ({
        name,
        dataVar: name.charAt(0).toLowerCase() + name.slice(1) // lower case first letter
      }))

    const all = [...proj.entities, ...proj.operations]
    if (all.length > 4)
      proj.allNames = `\n  ${all.map(e => e.name).join(',\n  ')}\n`
    else if (all.length)
      proj.allNames = all.map(e => e.name).join(', ')

    console.log(dim(`> Writing ${outPath}`))
    const destPath = dirname(destFile)
    await renderAndCopy(join(__dirname, 'files'), destPath, proj)
    await rename(join(destPath, 'handler.xs'), destFile)
  }
}

/**
 * @returns { Promise<import('@cap-js/cds-types').linked.LinkedCSN | null> }
 */
async function loadModel() {
  try {
    return cds.linked(cds.minify(await cds.load([cds.env.roots])))
  } catch (err) {
    if (err.code === 'MODEL_NOT_FOUND')  return null
    throw err
  }
}
